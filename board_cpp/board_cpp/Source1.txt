/*
#include <iostream>
#include <bitset>
#include <vector>

#ifdef _WIN32
#include <Windows.h>
#else
#include <unistd.h>

#endif
#define bitboard unsigned long long
#define movecontainervector std::vector<MoveContainer>
#define movevector std::vector<uint16_t>

uint8_t BYTE_SET_COUNT_LOOKUP[256];
uint8_t* ROW_PIECE_COLS_LOOKUP[256];
uint8_t max_move_count;
const bitboard BYTE_END = (bitboard)1 << 63;
const bitboard LL1 = (bitboard)1;
const bitboard LLF = (bitboard)0;
const bitboard LLT = (bitboard)-1;
const bitboard LLC[2] = { LLF , LLT };

struct MoveContainer {
	uint16_t moves[4] = {};
	uint8_t move_count;
	bitboard control_bitboards[4] = {};
	uint8_t control_mask = 0;
	MoveContainer(uint16_t* _moves, uint8_t _move_count) {
		std::memcpy(&moves, _moves, 4 * sizeof(uint16_t));
		move_count = _move_count;
	}
	MoveContainer() {
		move_count = 0;
	}
};

uint8_t* AXIAL_MOVES_LOOKUP[256][16];
uint8_t AXIAL_MOVE_COUNT_LOOKUP[256][16];
uint8_t AXIAL_MOVES_CONTROL_LOOKUP[256][16];

//up << 8
//down >> 8
//right << 1
//left >> 1

//(ul)(dl)(ur)(dr)
const uint8_t AXIAL_MASKS[8] = {
	0,
	0b1100,
	0,
	0b0011,
	0,
	0b1010,
	0,
	0b0101,
};

const bitboard DIAG_MAIN_BOARD = 0x8040201008040201;
const bitboard DIAG_RVRS_BOARD = 0x0102040810204080;


// urdl(ur)(dr)(dl)(ul)
const uint8_t DIRECTIONAL_POSITIONS[8] = {
	0b0001,
	0b0100,
	0b1001,
	0b0110,

	0b0000,
	0b1000,
	0b1010,
	0b0010
};

// urdl(ur)(dr)(dl)(ul)
const uint8_t CIRCULAR_MASK_LOOKUP[8] = {
	0b0100,
	0b1000,
	0b0010,
	0b0001,
	0b0010,
	0b0001,
	0b0100,
	0b1000
};

void bytes_to_board(uint8_t bytes[16], bitboard board[2]) {
	std::memcpy(&board[0], bytes, sizeof(bitboard));
	std::memcpy(&board[1], bytes + 8, sizeof(bitboard));
}

void print_move(uint16_t move) {
	std::cout << "move (" << int((move >> 8) & 7) << "," << int((move >> 11) & 7) << ") to (";
	std::cout << int((move) & 7) << "," << int((move >> 3) & 7) << ")\n";
}

uint8_t generate_byte_set_count(uint8_t byte) {
	static const uint8_t NIBBLE_LOOKUP[16] =
	{
	  0, 1, 1, 2, 1, 2, 2, 3,
	  1, 2, 2, 3, 2, 3, 3, 4
	};

	return NIBBLE_LOOKUP[byte & 0x0F] + NIBBLE_LOOKUP[byte >> 4];
}

uint8_t* generate_row_piece_cols(uint8_t byte) {
	uint8_t count = BYTE_SET_COUNT_LOOKUP[byte];
	//TODO remove static and add lookup
	static uint8_t* cols = new uint8_t[count];
	uint8_t index = 0;
	for (uint8_t col = 0; col < 8; col++) {
		if ((byte & (1 << col)) != 0) {
			cols[index] = col;
		}
	}
	return cols;
}

uint8_t* generate_axial_moves(uint8_t sides_byte, uint8_t corners_byte) {
	int index1 = 0;
	int arrindex = 0;

	uint8_t* moves = new uint8_t[4];
	while (index1 < 4) {
		if ((CIRCULAR_MASK_LOOKUP[index1] & sides_byte) != 0) {
			int index2 = (index1 + 1) % 4;
			int piece_moves = 0;
			uint8_t mini_control_mask = 0;
			while ((
				(CIRCULAR_MASK_LOOKUP[index2] & (sides_byte >> 4)) |
				(CIRCULAR_MASK_LOOKUP[(index2 + 3) % 4 + 4] & (corners_byte))) == 0 && piece_moves < 3) {
				mini_control_mask |= 1 << index2;
				if ((CIRCULAR_MASK_LOOKUP[index2] & sides_byte) == 0) {
					moves[arrindex] = (DIRECTIONAL_POSITIONS[index1] << 4) | DIRECTIONAL_POSITIONS[index2];
					arrindex++;
					index2 = (index2 + 1) % 4;
					piece_moves++;
				}
				else {
					break;
				}

			}
			index2 = (index1 + 3) % 4;
			while ((
				(CIRCULAR_MASK_LOOKUP[index2] & (sides_byte >> 4)) |
				(CIRCULAR_MASK_LOOKUP[index2 + 4] & (corners_byte))) == 0 && piece_moves < 3) {
				mini_control_mask |= 1 << index2;
				if ((CIRCULAR_MASK_LOOKUP[index2] & sides_byte) == 0) {
					moves[arrindex] = (DIRECTIONAL_POSITIONS[index1] << 4) | DIRECTIONAL_POSITIONS[index2];
					arrindex++;
					index2 = (index2 + 3) % 4;
					piece_moves++;
				}
				else {
					break;
				}

			}
			for (int i = 0; i < 4; i++) {
				uint8_t AMCL = AXIAL_MOVES_CONTROL_LOOKUP[sides_byte][corners_byte];
				AXIAL_MOVES_CONTROL_LOOKUP[sides_byte][corners_byte] &= ~(3 << (i * 2));
				AXIAL_MOVES_CONTROL_LOOKUP[sides_byte][corners_byte] |=
					(((AMCL >> i * 2) & 3) + int(((mini_control_mask >> i) & 1) == 1)) << i * 2;
			}

		}
		index1 += 1;
	}
	AXIAL_MOVES_LOOKUP[sides_byte][corners_byte] = moves;
	AXIAL_MOVE_COUNT_LOOKUP[sides_byte][corners_byte] = arrindex;
	return moves;

}

int count_pieces(uint8_t board[16], uint8_t is_second_player) {
	int count = 0;
	for (int i = 0; i < 8; i++) {
		count += BYTE_SET_COUNT_LOOKUP[board[i + 8 * is_second_player]];
	}
	return count;
}

int count_pieces(bitboard half_board) {
	int count = 0;
	uint8_t* board_bytes = reinterpret_cast<uint8_t*>(&half_board);
	for (int i = 0; i < 8; i++) {
		count += BYTE_SET_COUNT_LOOKUP[(*(board_bytes + i))];
	}
	return count;
}

uint8_t get_piece_at_pos(uint8_t board[16], uint8_t x, uint8_t y, uint8_t is_second_player) {
	if (x < 0 || x > 7 || y < 0 || y > 7) {
		return 2;
	}
	if ((board[y + 8 * is_second_player] & (1 << x)) != 0) {
		return 1;
	}
	return 0;
}
uint8_t get_piece_from_byte(uint8_t board[16], uint8_t pos, uint8_t is_second_player) {
	if ((board[(pos >> 3) + 8 * is_second_player] & (1 << (pos & 7))) != 0) {
		return 1;
	}
	return 0;
}

uint8_t get_circular_byte(bitboard half_board, uint8_t x, uint8_t y) {
	//(ul)(u)(ur)(l)(r)(dl)(d)(dr)
	//cscsscsc
	uint8_t circular_byte = 0;
	uint8_t* board_bytes = reinterpret_cast<uint8_t*>(&half_board);
	//L-R
	circular_byte |= ((((*(board_bytes + y)) >> (x - 1)) << 3) & 0b00001000);
	circular_byte |= ((((*(board_bytes + y)) >> (x + 1)) << 4) & 0b00010000);
	//U
	circular_byte |= (((*(board_bytes + y - 1))) >> 1) & 0b11100000 & LLC[int(x == 7)];
	circular_byte |= (((*(board_bytes + y - 1))) << (6 - x)) & 0b11100000 & LLC[int(x != 7)];
	//D
	circular_byte |= ((*(board_bytes + y + 1)) << 1) & 0b00000111 & LLC[int(x == 0)];
	circular_byte |= ((*(board_bytes + y + 1)) >> (x - 1)) & 0b00000111 & LLC[int(x != 0)];

	return circular_byte;
}

uint8_t get_sides_from_circular_bytes(uint8_t b1, uint8_t b2) {
	// rudlrudl
	return (b1 & 0b1010) | ((b1 >> 4) & 0b0101) | (b2 & 0b01010000) | ((b2 << 4) & 0b10100000);
}
uint8_t get_corners_from_circular_bytes(uint8_t b1, uint8_t b2) {
	//(ul)(dl)(ur)(dr)
	return (b1 & 0b0101) | ((b1 >> 4) & 0b1010) | (b2 & 0b0101) | ((b2 >> 4) & 0b1010);
}




void get_axial_moves(bitboard board[2], uint8_t pos, uint8_t is_second_player, MoveContainer& moves) {
	uint8_t player_byte, opponent_byte, sides_byte, corners_byte;
	uint8_t off_limits_mask = AXIAL_MASKS[int((pos & 7) == 7)] | AXIAL_MASKS[2 + int((pos & 7) == 0)]
		| AXIAL_MASKS[4 + int((pos & 56) == 0)] | AXIAL_MASKS[6 + int((pos & 56) == 56)];
	uint8_t x = (pos & 7);
	uint8_t y = ((pos >> 3) & 7);
	player_byte = get_circular_byte(board[is_second_player], x, y);
	opponent_byte = get_circular_byte(board[1 - is_second_player], x, y);
	sides_byte = get_sides_from_circular_bytes(player_byte, opponent_byte);
	corners_byte = get_corners_from_circular_bytes(player_byte, opponent_byte) | off_limits_mask;
	moves.move_count += AXIAL_MOVE_COUNT_LOOKUP[sides_byte][corners_byte];

	uint8_t* premade_moves = AXIAL_MOVES_LOOKUP[sides_byte][corners_byte];
	uint8_t move_count = AXIAL_MOVE_COUNT_LOOKUP[sides_byte][corners_byte];
	for (int i = 0; i < move_count; i++) {
		uint8_t rpos1 = ((premade_moves[i] >> 4) & 0b0011) | ((premade_moves[i] >> 3) & 0b11000);
		uint8_t pos1 = int8_t(pos) + int8_t(rpos1) - 9;
		uint8_t rpos2 = ((premade_moves[i]) & 0b0011) | ((premade_moves[i] << 1) & 0b11000);
		uint8_t pos2 = int8_t(pos) + int8_t(rpos2) - 9;
		moves.moves[i] = (uint16_t(pos1) << 8) | uint16_t(pos2);
	}
	moves.control_mask = AXIAL_MOVES_CONTROL_LOOKUP[sides_byte][corners_byte];
}

void get_diagonal_moves(bitboard board[2], uint8_t pos, uint8_t is_second_player, MoveContainer& moves) {
	uint8_t x = (pos & 7);
	uint8_t y = ((pos >> 3) & 7);
	unsigned long final_pos;
	bitboard main_diagonal = ((DIAG_MAIN_BOARD >> (8 * (x - y))) | LLC[int((x - y) < 0)])
		& ((DIAG_MAIN_BOARD << (8 * (y - x))) | LLC[int((x - y) >= 0)]);
	bitboard rvrs_diagonal = ((DIAG_RVRS_BOARD << (8 * (x + y - 7))) | LLC[int((x + y - 7) < 0)])
		& ((DIAG_RVRS_BOARD >> (8 * (7 - x - y))) | LLC[int((x + y - 7) >= 0)]);
	bitboard upper_mask = (LLT >> 8 * (8 - y)) & LLC[int(y != 0)];
	bitboard higher_upper_mask = (LLT >> 8 * (9 - y)) & LLC[int(y > 1)];
	bitboard bottom_mask = (LLT << 8 * (y + 1)) & LLC[int(y != 7)];
	bitboard lower_bottom_mask = (LLT << 8 * (y + 2)) & LLC[int(y < 6)];
	uint16_t pos16 = (uint16_t(pos) << 8);

	//UP RIGHT

	bitboard vur_positions = upper_mask & ~board[is_second_player] & main_diagonal;

	_BitScanReverse64(&final_pos, vur_positions);
	if (x - (final_pos & 7) != 1 && vur_positions != 0) {
		moves.control_bitboards[0] = higher_upper_mask & main_diagonal & (LLT << 8 * (final_pos >> 3));
		moves.moves[moves.move_count] = pos16 | uint16_t(final_pos);
		moves.move_count++;
	}

	//UP LEFT
	bitboard vul_positions = upper_mask & ~board[is_second_player] & rvrs_diagonal;

	_BitScanReverse64(&final_pos, vul_positions);
	if ((final_pos & 7) - x != 1 && vul_positions != 0) {
		moves.control_bitboards[1] = higher_upper_mask & rvrs_diagonal & (LLT << 8 * (final_pos >> 3));
		moves.moves[moves.move_count] = pos16 | uint16_t(final_pos);
		moves.move_count++;
	}

	//DOWN LEFT
	bitboard vdl_positions = bottom_mask & ~board[is_second_player] & main_diagonal;

	_BitScanForward64(&final_pos, vdl_positions);
	if ((final_pos & 7) - x != 1 && vdl_positions != 0) {
		moves.control_bitboards[1] = lower_bottom_mask & main_diagonal & (LLT >> 8 * (7 - (final_pos >> 3)));
		moves.moves[moves.move_count] = pos16 | uint16_t(final_pos);
		moves.move_count++;
	}

	//DOWN RIGHT
	bitboard vdr_positions = bottom_mask & ~board[is_second_player] & rvrs_diagonal;

	_BitScanForward64(&final_pos, vdr_positions);
	if (x - (final_pos & 7) != 1 && vdr_positions != 0) {
		moves.control_bitboards[1] = lower_bottom_mask & rvrs_diagonal & (LLT >> 8 * (7 - (final_pos >> 3)));
		moves.moves[moves.move_count] = pos16 | uint16_t(final_pos);
		moves.move_count++;
	}
}

void show_board_moves(movevector moves) {
	for (int i = 0; i < moves.size(); i++) {
		print_move(moves[i]);
	}
	std::cout << "move_count = " << moves.size() << "\n";
}

void add_bitboards_to_control_board(uint8_t control_board[64], bitboard control_bitboard[4], uint8_t axial_mask, uint8_t pos) {
	bitboard combined = control_bitboard[0] | control_bitboard[1] | control_bitboard[2] | control_bitboard[3];
	for (int i = 0; i < 64; i++) {
		control_board[i] += (combined & LL1);
		combined = combined >> 1;
	}
	control_board[(pos + 64 - 8) % 64] += (axial_mask) & 3;
	control_board[(pos + 64 - 1) % 64] += (axial_mask >> 2) & 3;
	control_board[(pos + 8) % 64] += (axial_mask >> 4) & 3;
	control_board[(pos + 1) % 64] += (axial_mask >> 6) & 3;
}

movevector find_board_moves(bitboard board[2], uint8_t is_second_player, uint8_t control_board[64]) {
	int total_move_count = 0;
	int piece_count = count_pieces(board[is_second_player]);
	if (piece_count == 0) {
		return movevector();
	}
	movecontainervector move_groups(piece_count);
	int current_piece = 0;
	int move_count = 0;
	for (int i = 0; i < 8; i++) {
		uint8_t current_byte = (board[is_second_player] >> (i * 8)) & 0xFF;
		uint8_t row_piece_count = BYTE_SET_COUNT_LOOKUP[current_byte];
		for (int j = 0; j < row_piece_count; j++) {
			unsigned long pos = 0;
			_BitScanForward(&pos, current_byte);

			MoveContainer moves;
			get_axial_moves(board, i * 8 + pos, is_second_player, moves);
			get_diagonal_moves(board, i * 8 + pos, is_second_player, moves);
			add_bitboards_to_control_board(control_board, moves.control_bitboards, moves.control_mask, i * 8 + pos);
			move_groups[current_piece] = moves;
			current_piece++;
			move_count += moves.move_count;
			if (current_piece == piece_count) {
				break;
			}
			current_byte = current_byte & ~(-current_byte);
		}
		if (current_piece == piece_count) {
			break;
		}
	}
	movevector final_moves(move_count);
	int move_index = 0;
	for (int i = 0; i < move_groups.size(); i++) {
		for (int j = 0; j < move_groups[i].move_count; j++) {
			final_moves[move_index] = move_groups[i].moves[j];
			move_index++;
		}
	}
	
	//for (int i = 0; i < 8; i++) {
		//for (int j = 0; j < 8; j++) {
			//std::cout << int(control_board[i * 8 + 7 - j]) << "\t";
		//}
		//std::cout << "\n";
	//}
	//
	return final_moves;

}

void show_board(bitboard board[2]) {
	for (int i = 0; i < 8; i++) {
		for (int j = 7; j >= 0; j--) {
			if ((board[0] & (LL1 << (j + 8 * i))) != 0) {
				std::cout << "O";
			}
			else if ((board[1] & (LL1 << (j + 8 * i))) != 0) {
				std::cout << "X";
			}
			else {
				std::cout << ".";
			}
		}
		std::cout << "\n";
	}
}


void initialize() {
	srand(time(0));
	//initialize BYTE_SET_COUNT_LOOKUP
	for (int i = 0; i < 256; i++) {
		BYTE_SET_COUNT_LOOKUP[i] = generate_byte_set_count(i);
	}
	BYTE_SET_COUNT_LOOKUP[255] = 8;
	for (int i = 0; i < 256; i++) {
		ROW_PIECE_COLS_LOOKUP[i] = generate_row_piece_cols(i);
	}
	for (int i = 0; i < 4096; i++) {
		generate_axial_moves(i & 0xFF, i >> 8);
	}

}

void get_control_values(bitboard board[2], uint8_t control_board1[64], uint8_t control_board2[64],
	int& p_safe, int& p_neutral, int& p_danger,
	int& o_safe, int& o_neutral, int& o_danger,
	int& e_safe, int& e_neutral, int& e_danger) {
	bitboard p1_control_bitboard = 0;
	bitboard p2_control_bitboard = 0;
	for (int i = 0; i < 64; i++) {
		int diff = (control_board1[i] - control_board1[i]);
		p1_control_bitboard |= (LL1 << i) & LLC[int(diff > 0)];
		p2_control_bitboard |= (LL1 << i) & LLC[int(diff < 0)];
	}
	bitboard n_conrol_bitboard = ~(p1_control_bitboard | p2_control_bitboard);
	bitboard n_bitboard = ~(board[0] | board[1]);
	p_safe = count_pieces(p1_control_bitboard & board[0]);
	p_neutral = count_pieces(n_conrol_bitboard & board[0]);
	p_danger = count_pieces(p2_control_bitboard & board[0]);

	o_safe = count_pieces(p2_control_bitboard & board[1]);
	o_neutral = count_pieces(n_conrol_bitboard & board[1]);
	o_danger = count_pieces(p1_control_bitboard & board[1]);

	p_safe = count_pieces(p1_control_bitboard & n_bitboard);
	p_neutral = count_pieces(n_conrol_bitboard & n_bitboard);
	p_danger = count_pieces(p2_control_bitboard & n_bitboard);

}

int pseudo_rate_board(bitboard board[2], uint8_t player_index) {
	uint8_t control_board1[64] = {};
	uint8_t control_board2[64] = {};
	int total_rating = 0;
	//p: player, o: opponent
	auto p_moves = find_board_moves(board, player_index, control_board1);
	auto o_moves = find_board_moves(board, 1 - player_index, control_board2);
	int p_move_count = p_moves.size();
	int o_move_count = o_moves.size();
	int p_safe, p_neutral, p_danger,
		o_safe, o_neutral, o_danger,
		e_safe, e_neutral, e_danger;
	get_control_values(board, control_board1, control_board2,
		p_safe, p_neutral, p_danger,
		o_safe, o_neutral, o_danger,
		e_safe, e_neutral, e_danger);
	return total_rating;
}

void do_stress_test(bitboard test_board[2], int n) {
	clock_t start, end;
	start = clock();
	bitboard new_test_board[2] = { test_board[0], test_board[1] };
	for (int i = 0; i < n; i++) {
		uint8_t control_board[64] = {};
		pseudo_rate_board(new_test_board, 0);
		new_test_board[0] = new_test_board[0] + 1;
		if (i == 900000) {
			show_board(new_test_board);
		}
	}
	end = clock();
	double time_taken = double(end - start) / double(CLOCKS_PER_SEC);
	std::cout << "time taken by program is : " << time_taken << " seconds\n";
}

void make_move(bitboard board[2], uint16_t move, uint8_t player_index) {
	board[player_index] = (board[player_index] | (LL1 << (move & 0xFF))) & ~(LL1 << ((move >> 8) & 0xFF));
	board[1 - player_index] = (board[1 - player_index] & ~(LL1 << (move & 0xFF)));
}

void auto_play_game(bitboard starting_board[2]) {
	bitboard current_board[2] = { starting_board[0],starting_board[1] };

	uint8_t current_player_index = 0;
	for (int i = 0; i < 100000; i++) {
		uint8_t control_board[64] = {};
		auto moves = find_board_moves(current_board, current_player_index, control_board);
		if (moves.size() == 0) {
			break;
		}
		auto move = moves[rand() % moves.size()];
		make_move(current_board, move, current_player_index);
		current_player_index = 1 - current_player_index;
		if (i < 20) {
			Sleep(1000 - 50 * i);
			show_board(current_board);
			std::cout << "\n";
		}

	}
	show_board(current_board);
}

int main() {
	initialize();
	uint8_t test_board_pre[16] = {
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b11111111,
		0b11111111,

		0b11111111,
		0b11111111,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
	};
	bitboard test_board[2];
	bytes_to_board(test_board_pre, test_board);

	show_board(test_board);

	std::cout << "\n";

	//show_board_moves(find_board_moves(test_board, 0));
	//auto_play_game(test_board);
	do_stress_test(test_board, 1000000);

	return 0;
}
*/